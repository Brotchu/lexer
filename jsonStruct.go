package generator

import (
	"fmt"
	"go/format"
	"lexer/ast"
	"log"
	"strings"
)

var codeString string

//TODO:
var space string

func JsonStruct(tree ast.RootNode) {
	walkTree(tree)
	fmt.Println("in generator")
}

func walkTree(node ast.RootNode) {
	fmt.Println("---------------")
	switch node.Type {
	case ast.ObjectRoot:
		codeString = "" //TODO:
		// codeString = "type AutoGenerated struct{\n"
		// fmt.Printf("%#v",node.RootValue)
		walkObj(node.RootValue.Content.(ast.Object))
	case ast.ArrayRoot:
		fmt.Println("Your root JSON type is an array.")
	}
	// codeString = codeString + "}"
	fmt.Println(codeString)

	//TODO:
	content, err := format.Source([]byte(codeString))
	if err != nil {
		log.Panic(err.Error())
	}
	fmt.Println(string(content))
}
func walkObj(obj ast.Object, a ...interface{}) {
	if a != nil {
		codeString += " struct{ \n" //TODO:
		tagString := fmt.Sprintf("%v", a[0])
		defer func() { codeString += "} `json:\" " + tagString + "\"`\n" }()
		fmt.Println("---CHILDREN OF", a)
	} else {
		codeString += "type AutoGenerated struct{\n"
		defer func() { codeString += "}\n" }()
	}
	for _, childObj := range obj.Children {
		// fmt.Println("[Key: ",childObj.Key.Value," Value: ",childObj.Value,"]\n")
		switch childObj.Value.(type) {
		case ast.Value:
			result := childObj.Value.(ast.Value)
			fmt.Println("KEY:", childObj.Key.Value)
			codeString = codeString + " " + strings.Title(childObj.Key.Value)
			switch result.Content.(type) {
			case ast.Literal:
				res := result.Content.(ast.Literal)
				switch res.ValueType {
				case ast.StringLiteralValueType:
					codeString = codeString + " string `json:\"" + childObj.Key.Value + "\"`\n"
				case ast.IntegerLiteralValueType:
					codeString = codeString + " int `json:\"" + childObj.Key.Value + "\"`\n"
				case ast.FloatLiteralValueType:
					codeString = codeString + " float64 `json:\"" + childObj.Key.Value + "\"`\n"
				case ast.NullLiteralValueType:
					codeString = codeString + " interface{} `json:\"" + childObj.Key.Value + "\"`\n"
				case ast.BooleanLiteralValueType:
					codeString = codeString + " bool `json:\"" + childObj.Key.Value + "\"`\n"
				}
				fmt.Printf("\n VALUE %+v", res)
			case ast.Object:
				res := result.Content.(ast.Object)
				walkObj(res, childObj.Key.Value)
			case ast.Array:
				res := result.Content.(ast.Array)
				walkArr(res, childObj.Key.Value)
			}
		}
		fmt.Println()
	}
	// codeString = codeString + "} \n" //TODO:
}
func walkArr(arr ast.Array, a ...interface{}) {
	if a != nil {
		fmt.Println("---CHILDREN OF", a)
	}
	for _, childObj := range arr.Children {
		// fmt.Println("[Key: ",childObj.Key.Value," Value: ",childObj.Value,"]\n")
		switch childObj.Value.(type) {
		case ast.Literal:
			res := childObj.Value.(ast.Literal)
			fmt.Printf("\n VALUE %+v", res)
		case ast.Object:
			res := childObj.Value.(ast.Object)
			walkObj(res)
		case ast.Array:
			res := childObj.Value.(ast.Array)
			fmt.Println("Array", res)
		}
		fmt.Println()
	}
}
