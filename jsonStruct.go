package generator

import (
	"fmt"
	"go/format"
	"lexer/ast"
	"log"
	"strings"
)

var codeString string

//TODO:
var space string

func JsonStruct(tree ast.RootNode) {
	walkTree(tree)
	fmt.Println("in generator")
}

func walkTree(node ast.RootNode) {
	fmt.Println("---------------")
	switch node.Type {
	case ast.ObjectRoot:
		codeString = "" //TODO:
		// codeString = "type AutoGenerated struct{\n"
		// fmt.Printf("%#v",node.RootValue)
		walkObj(node.RootValue.Content.(ast.Object))
	case ast.ArrayRoot:
		fmt.Println("Your root JSON type is an array.")
	}
	// codeString = codeString + "}"
	fmt.Println(codeString)

	//TODO:
	content, err := format.Source([]byte(codeString))
	if err != nil {
		log.Panic(err.Error())
	}
	fmt.Println(string(content))
}
func walkObj(obj ast.Object, a ...interface{}) {
	if a != nil {
		codeString += " struct{ \n" //TODO:
		tagString := fmt.Sprintf("%v", a[0])
		defer func() { codeString += "} `json:\" " + tagString + "\"`\n" }()
		fmt.Println("---CHILDREN OF", a)
	} else {
		codeString += "type AutoGenerated struct{\n"
		defer func() { codeString += "}\n" }()
	}
	for _, childObj := range obj.Children {
		// fmt.Println("[Key: ",childObj.Key.Value," Value: ",childObj.Value,"]\n")
		switch childObj.Value.(type) {
		case ast.Value:
			result := childObj.Value.(ast.Value)
			fmt.Println("KEY:", childObj.Key.Value)
			codeString = codeString + " " + strings.Title(childObj.Key.Value)
			switch result.Content.(type) {
			case ast.Literal:
				res := result.Content.(ast.Literal)
				switch res.ValueType {
				case ast.StringLiteralValueType:
					codeString = codeString + " string `json:\"" + childObj.Key.Value + "\"`\n"
				case ast.IntegerLiteralValueType:
					codeString = codeString + " int `json:\"" + childObj.Key.Value + "\"`\n"
				case ast.FloatLiteralValueType:
					codeString = codeString + " float64 `json:\"" + childObj.Key.Value + "\"`\n"
				case ast.NullLiteralValueType:
					codeString = codeString + " interface{} `json:\"" + childObj.Key.Value + "\"`\n"
				case ast.BooleanLiteralValueType:
					codeString = codeString + " bool `json:\"" + childObj.Key.Value + "\"`\n"
				}
				fmt.Printf("\n VALUE %+v", res)
			case ast.Object:
				res := result.Content.(ast.Object)
				walkObj(res, childObj.Key.Value)
			case ast.Array:
				res := result.Content.(ast.Array)
				codeString += walkArr(res, childObj.Key.Value) + "\n"
			}
		}
		fmt.Println()
	}
	// codeString = codeString + "} \n" //TODO:
}
func walkArr(arr ast.Array, a ...interface{}) string {
	if a != nil {
		fmt.Println("---CHILDREN OF", a)
	}

	flagLiteral, flagObj, flagArray := false, false, false
	for _, childObj := range arr.Children {
		log.Printf("%v\n", childObj.Value)
		switch childObj.Value.(type) {
		case ast.Literal:
			flagLiteral = true
		case ast.Object:
			flagObj = true
		case ast.Array:
			flagArray = true
		}
	}
	tagString := fmt.Sprintf("%v", a[0])
	fmt.Println(flagLiteral, flagObj, flagArray)
	switch true {
	case flagArray && flagLiteral && flagObj:
		fmt.Println("[]interface{}")
		return "[]interface{}" + "`json:\"" + tagString + "\"`"
	case flagArray && flagLiteral:
		fmt.Println("[]interface{}")
		return "[]interface{}" + "`json:\"" + tagString + "\"`"
	case flagArray && flagObj:
		fmt.Println("[]interface{}")
		return "[]interface{}" + "`json:\"" + tagString + "\"`"
	case flagLiteral && flagObj:
		fmt.Println("[]interface{}")
		return "[]interface{}" + "`json:\"" + tagString + "\"`"
	case flagLiteral:
		//see if it is all same type
		return " []" + findArrayType(arr) + " `json:\"" + tagString + "\"`"
	case flagArray:
		childTypes := []string{}
		for _, child := range arr.Children {
			switch child.Value.(type) {
			case ast.Array:
				childTypes = append(childTypes, walkArr(child.Value.(ast.Array)))
			}
		}
		fmt.Printf("-----------%v\n", childTypes)
		return "[]" + areSame(childTypes)
	default:
		return "interface{}"
	}

	// for _, childObj := range arr.Children {
	// 	// fmt.Println("[Key: ",childObj.Key.Value," Value: ",childObj.Value,"]\n")
	// 	switch childObj.Value.(type) {
	// 	case ast.Literal:
	// 		res := childObj.Value.(ast.Literal)
	// 		fmt.Printf("\n VALUE %+v", res)
	// 	case ast.Object:
	// 		res := childObj.Value.(ast.Object)
	// 		walkObj(res)
	// 	case ast.Array:
	// 		res := childObj.Value.(ast.Array)
	// 		fmt.Println("Array", res)
	// 	}
	// 	fmt.Println()
	// }
}

func findArrayType(arr ast.Array) string {
	var res ast.LiteralValueType = ast.NullLiteralValueType
	for i, child := range arr.Children {
		t := child.Value.(ast.Literal).ValueType
		fmt.Printf("result is %v child type is %v child is %+v\n", res, t, child)
		if i == 0 {
			fmt.Println("assigning result as : ", t, "from ", child.Value.(ast.Literal).Value)
			res = t
		} else {
			if child.Value.(ast.Literal).Value != "," && res != t {
				return "interface{}"
			}
		}
	}

	switch res {
	case ast.StringLiteralValueType:
		return "string"
	case ast.IntegerLiteralValueType:
		return "int"
	case ast.FloatLiteralValueType:
		return "float"
	case ast.NullLiteralValueType:
		return "interface{}"
	case ast.BooleanLiteralValueType:
		return "bool"
	default:
		return "interface{}"
	}
}

func areSame(c []string) string {
	if len(c) == 0 {
		return "[]interface{}"
	}
	for i := 1; i < len(c); i++ {
		if c[i] != c[0] {
			return "[]interface{}"
		}
	}
	return c[0]
}
